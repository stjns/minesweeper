{"mappings":"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","sources":["<anon>","src/main.ts","src/models/Gameboard.ts","src/models/Minefield.ts","src/models/Cell.ts","src/models/CellCoordinate.ts","src/models/NearbyCellMap.ts","src/models/Stopwatch.ts","src/models/MineCounter.ts"],"sourcesContent":["// An individual cell within the minefield\nclass $f03a6e87241b40b6$export$f6f0c3fe4ec306ea {\n    constructor(cellRevealCallback, cellFlagCallback, multiFlagCallback, chordCallback){\n        this.mineNeighbors = 0;\n        this.mined = false;\n        this.flagged = false;\n        this.exploded = false;\n        this.revealed = false;\n        this.disabled = false;\n        this.flaggingEnabled = false;\n        this.touchTimer = 0;\n        this.BOMB_CODE = \"&#x1f4a3;\";\n        this.FLAG_CODE = \"&#x26f3;\";\n        this.isFlagged = ()=>this.flagged;\n        this.isRevealed = ()=>this.revealed;\n        this.numNearbyMines = ()=>this.mineNeighbors;\n        this.isEmpty = ()=>this.mineNeighbors === 0;\n        this.isMined = ()=>this.mined;\n        this.htmlElement = document.createElement(\"div\");\n        this.cellRevealCallback = cellRevealCallback;\n        this.cellFlagCallback = cellFlagCallback;\n        this.multiFlagCallback = multiFlagCallback;\n        this.chordCallback = chordCallback;\n        this.htmlElement.classList.add(\"game-cell\");\n        this.htmlElement.classList.add(\"un-revealed\");\n        this.htmlElement.addEventListener(\"contextmenu\", (e)=>{\n            e.preventDefault();\n            this.toggleFlag();\n        });\n        this.htmlElement.addEventListener(\"click\", ()=>this.reveal());\n        this.htmlElement.addEventListener(\"touchstart\", (e)=>this.touchHandler(e));\n        this.htmlElement.addEventListener(\"touchend\", ()=>this.cancelTouch());\n        this.htmlElement.addEventListener(\"touchmove\", ()=>this.cancelTouch());\n    }\n    touchHandler(e) {\n        e.preventDefault();\n        if (!this.touchTimer) this.touchTimer = setTimeout(()=>{\n            this.touchTimer = 0;\n            this.toggleFlag();\n        }, 250);\n    }\n    cancelTouch() {\n        if (this.touchTimer) {\n            clearTimeout(this.touchTimer);\n            this.touchTimer = 0;\n            this.reveal();\n        }\n    }\n    //set a mine on this cell\n    arm() {\n        this.mined = true;\n        this.mineNeighbors = 1;\n    }\n    //needed to prevent a bug for flagging before the game has started\n    enableFlagging() {\n        this.flaggingEnabled = true;\n    }\n    //set the number that will appear on a cell\n    setMinedNeighbors(minedNeighbors) {\n        if (!this.mined) this.mineNeighbors = minedNeighbors;\n    }\n    //action when an unflagged cell is clicked\n    reveal() {\n        if (!this.disabled && !this.flagged && !this.revealed) {\n            this.revealed = true;\n            if (this.mined) {\n                this.cellRevealCallback(true);\n                this.exploded = true;\n                this.htmlElement.classList.add(\"exploded\");\n                this.htmlElement.innerHTML = this.BOMB_CODE;\n            } else {\n                this.cellRevealCallback(false);\n                if (this.mineNeighbors > 0) {\n                    this.htmlElement.textContent = this.mineNeighbors.toString();\n                    this.htmlElement.classList.add(`n${this.mineNeighbors}`);\n                }\n            }\n            this.htmlElement.classList.remove(\"un-revealed\");\n        } else if (this.revealed && this.mineNeighbors > 0) this.chordCallback(this.mineNeighbors);\n    }\n    //when the game is over disable the cell from being clicked \n    gameOver() {\n        this.disabled = true;\n        if (this.mined && !this.flagged && !this.exploded) {\n            this.htmlElement.classList.add(\"unexploded-mine\");\n            this.htmlElement.innerHTML = this.BOMB_CODE;\n        } else if (!this.mined && this.flagged) this.htmlElement.classList.add(\"bad-flag\");\n    }\n    //add/remove flag from an unrevelead cell\n    toggleFlag() {\n        if (this.flaggingEnabled && !this.disabled && !this.isRevealed()) {\n            if (!this.isFlagged()) this.htmlElement.innerHTML = this.FLAG_CODE;\n            else this.htmlElement.textContent = \" \";\n            this.flagged = !this.flagged;\n            this.cellFlagCallback(this.flagged);\n        } else if (this.revealed && this.mineNeighbors > 0) this.multiFlagCallback(this.mineNeighbors);\n    }\n}\n\n\nclass $d74dfbfeecf2573c$export$938320e50a99d1b5 {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n}\n\n\nclass $398861d148eae71c$export$ef6ffcab40d2e0ba {\n    constructor(){\n        this.Unflagged = [];\n        this.Flagged = [];\n        this.Unrevealed = 0;\n    }\n}\n\n\nclass $9dea8592a9741d26$export$3e25d3fc3a58268c {\n    constructor(width, height, mines, gameStartCallback, gameEndCallback, mineCountCallback){\n        this.remainingMines = 0;\n        this.virginBoard = true //new, untouched minefield\n        ;\n        //check to see if a user has won by flagging all mines\n        this.checkForWinByFlags = ()=>this.cells.flatMap((r)=>r.filter((c)=>c.isMined() && !c.isFlagged())).length === 0;\n        this.boardHeight = height;\n        this.boardWidth = width;\n        this.mineCount = mines;\n        this.remainingMines = mines;\n        this.gameEndCallback = gameEndCallback;\n        this.gameStartCallback = gameStartCallback;\n        this.mineCountCallback = mineCountCallback;\n        this.mineCountCallback(mines);\n        this.cells = [\n            ...Array(width)\n        ].map((e)=>Array(height));\n        this.populateBoard();\n    }\n    //create a randomized minefield based on height/width/mines specified\n    //leave a gap at the point of the initial click\n    generateMineMap(initialX, initialY, width, height, mineCount) {\n        const allCells = []; //all possible cells\n        const minedCells = []; //cells that have a mine\n        //populate full cellArray with all possible cell coordinates\n        for(let y = 0; y < height; y++)for(let x = 0; x < width; x++)allCells.push(new (0, $d74dfbfeecf2573c$export$938320e50a99d1b5)(x, y));\n        //remove the initial clicked cell and all it's immediate neighbors\n        //as possible locations for a mine\n        const mineableCells = [];\n        for (const cell of allCells){\n            if (cell.x >= initialX - 1 && cell.x <= initialX + 1 && cell.y >= initialY - 1 && cell.y <= initialY + 1) continue;\n            mineableCells.push(cell);\n        }\n        //add the specified number of mines randomly to the remaining cells\n        for(let m = 0; m < mineCount; m++){\n            const randomCellNum = Math.floor(Math.random() * mineableCells.length);\n            minedCells.push(...mineableCells.splice(randomCellNum, 1));\n        }\n        return minedCells;\n    }\n    populateBoard() {\n        for(let y = 0; y < this.boardHeight; y++)for(let x = 0; x < this.boardWidth; x++){\n            const newCell = new (0, $f03a6e87241b40b6$export$f6f0c3fe4ec306ea)((result)=>this.cellRevealCallback(result, x, y), (flagged)=>this.cellFlagCallback(flagged), (nearby)=>this.multiFlagCallback(x, y, nearby), (nearby)=>this.chordCallback(x, y, nearby));\n            this.cells[x][y] = newCell;\n        }\n    }\n    //chording is when you do a normal click on a revealed cell in order\n    //to reveal its unrevealed neighbors. If the number of nearby flagged cells\n    //equals the number on the clicked cell, each unflagged, unrevealed cell should\n    //be revealed. This can result in game loss. \n    chordCallback(x, y, mineNeighbors) {\n        const cellMap = this.mapNearbyCells(x, y);\n        if (cellMap.Flagged.length === mineNeighbors) cellMap.Unflagged.forEach((cell)=>cell.reveal());\n    }\n    //get a map of all nearby cells and their states\n    mapNearbyCells(x, y) {\n        const cellMap = new (0, $398861d148eae71c$export$ef6ffcab40d2e0ba)();\n        const minY = y === 0 ? 0 : y - 1;\n        const maxY = y === this.boardHeight - 1 ? y : y + 1;\n        const minX = x === 0 ? 0 : x - 1;\n        const maxX = x === this.boardWidth - 1 ? x : x + 1;\n        for(let itY = minY; itY <= maxY; itY++)for(let itX = minX; itX <= maxX; itX++){\n            if (itX === x && itY === y) continue; //no need to count myself\n            const currentCell = this.cells[itX][itY];\n            if (!currentCell.isRevealed()) cellMap.Unrevealed++;\n            if (!currentCell.isRevealed() && currentCell.isFlagged()) cellMap.Flagged.push(currentCell);\n            if (!currentCell.isRevealed() && !currentCell.isFlagged()) cellMap.Unflagged.push(currentCell);\n        }\n        return cellMap;\n    }\n    //when a cell gets flagged, we need to recalculate the number\n    //of remaining mines. Also, this can flag other cells if the\n    //user uses the convience feature of flagging a \"numbered\" \n    //revealed cell.\n    cellFlagCallback(flagged) {\n        if (flagged) this.mineCountCallback(--this.remainingMines);\n        else this.mineCountCallback(++this.remainingMines);\n        if (this.checkForWinByFlags()) this.winnerWinner();\n    }\n    multiFlagCallback(x, y, nearbyMined) {\n        const cellMap = this.mapNearbyCells(x, y);\n        if (cellMap.Unrevealed === nearbyMined) cellMap.Unflagged.forEach((n)=>n.toggleFlag());\n    }\n    //set the number that will appear on the cells near a mine\n    calculateMinedNeighbors() {\n        for(let y = 0; y < this.boardHeight; y++){\n            for(let x = 0; x < this.boardWidth; x++)if (!this.cells[x][y].isMined()) {\n                let count = 0;\n                //calculate current row\n                if (x > 0 && this.cells[x - 1][y].isMined()) count++;\n                if (x < this.boardWidth - 1 && this.cells[x + 1][y].isMined()) count++;\n                //calculate above row\n                if (y > 0) {\n                    if (x > 0 && this.cells[x - 1][y - 1].isMined()) count++;\n                    if (this.cells[x][y - 1].isMined()) count++;\n                    if (x < this.boardWidth - 1 && this.cells[x + 1][y - 1].isMined()) count++;\n                }\n                //calculate below row\n                if (y < this.boardHeight - 1) {\n                    if (x > 0 && this.cells[x - 1][y + 1].isMined()) count++;\n                    if (this.cells[x][y + 1].isMined()) count++;\n                    if (x < this.boardWidth - 1 && this.cells[x + 1][y + 1].isMined()) count++;\n                }\n                this.cells[x][y].setMinedNeighbors(count);\n            }\n        }\n    }\n    //right after the first move we need to do a bunch of stuff,\n    //like calculating the minefield, enabling flagging\n    firstMove(x, y) {\n        const mineMap = this.generateMineMap(x, y, this.boardWidth, this.boardHeight, this.mineCount);\n        for(let y = 0; y < this.boardHeight; y++)for(let x = 0; x < this.boardWidth; x++){\n            if (mineMap.some((c)=>c.x === x && c.y === y)) this.cells[x][y].arm();\n            this.cells[x][y].enableFlagging();\n        }\n        this.calculateMinedNeighbors();\n        this.virginBoard = false;\n        this.gameStartCallback();\n    }\n    /*\n     * When a cell is revealed, this function is run to see what actions\n     * the board should take, eg declare win, loss, or propagate an empty\n     * cell field. In the latter case, this method is recursive.\n     * \n     * If the cell is not empty or mined, we don't need to do anything.\n     * \n     * result: false if the cell is mined, true if it is\n     * x, y: coordinates for the revealed cell\n     */ cellRevealCallback(mined, x, y) {\n        //on the first click, we need to calculate the mines before we\n        //do anything else\n        if (this.virginBoard) this.firstMove(x, y);\n        if (mined) {\n            //explode\n            this.gameEndCallback();\n            this.disableAllCells();\n        } else if (this.cells[x][y].isEmpty()) //propagate empty cells\n        for(let x2 = x - 1; x2 < x + 2; x2++){\n            for(let y2 = y - 1; y2 < y + 2; y2++)if (x2 >= 0 && x2 < this.boardWidth && y2 >= 0 && y2 < this.boardHeight && !this.cells[x2][y2].isRevealed()) {\n                this.cells[x2][y2].reveal();\n                if (this.cells[x2][y2].isEmpty()) this.cellRevealCallback(false, x2, y2);\n            }\n        }\n        else //check for win\n        if (this.checkForWin()) this.winnerWinner();\n    }\n    //used when the user has won to flag remaining mines\n    flagAllMinesRevealUnrevealed() {\n        for (const row of this.cells)for (const cell of row){\n            if (cell.isMined() && !cell.isFlagged()) cell.toggleFlag();\n            else if (!cell.isRevealed()) cell.reveal();\n        }\n    }\n    winnerWinner() {\n        this.gameEndCallback();\n        this.flagAllMinesRevealUnrevealed();\n        this.disableAllCells();\n    }\n    //check to see if the user has won\n    //TODO probably a smarter way to do this?\n    checkForWin() {\n        for (const row of this.cells)for (const cell of row){\n            if (!cell.isRevealed() && !cell.isMined()) return false;\n        }\n        return true;\n    }\n    //used when the user has won/lost to prevent further clicks\n    disableAllCells() {\n        for (const row of this.cells)for (const cell of row)cell.gameOver();\n    }\n    //start a new game!\n    newGame() {\n        const mainDiv = document.createElement(\"div\");\n        for(let y = 0; y < this.boardHeight; y++){\n            const newCellRow = document.createElement(\"div\");\n            newCellRow.classList.add(\"cell-row\");\n            for(let x = 0; x < this.boardWidth; x++)newCellRow.appendChild(this.cells[x][y].htmlElement);\n            mainDiv.appendChild(newCellRow);\n        }\n        return mainDiv;\n    }\n}\n\n\nclass $d853b51430cfd2d2$export$e16de4ea1abb52c8 {\n    constructor(){\n        this.interval = 0;\n        this.offset = 0;\n        this.timer = document.createElement(\"div\");\n        this.timer.classList.add(\"game-timer\");\n        this.render(0);\n    }\n    start() {\n        this.reset();\n        if (!this.interval) {\n            this.offset = Date.now();\n            this.interval = setInterval(()=>this.update(), 100);\n        }\n    }\n    reset() {\n        this.stop();\n        this.render(0);\n    }\n    stop() {\n        if (this.interval) {\n            clearInterval(this.interval);\n            this.interval = 0;\n        }\n    }\n    update() {\n        this.render(Date.now() - this.offset);\n    }\n    render(time) {\n        const minutes = Math.floor(time / 60000).toString().padStart(2, \"0\");\n        const seconds = (time % 60000 / 1000).toFixed(1).padStart(4, \"0\");\n        this.timer.innerHTML = `${minutes}:${seconds}`;\n    }\n}\n\n\nclass $660a63c9b22e7366$export$d6b7f92e63aee0e4 {\n    constructor(initialCount){\n        this.BOMB_CODE = \"&#x1f4a3;\";\n        this.counterDiv = document.createElement(\"div\");\n        this.counterDiv.id = \"mine-counter\";\n        this.currentCount = initialCount;\n        this.render();\n    }\n    set(count) {\n        this.currentCount = count;\n        this.render();\n    }\n    render() {\n        this.counterDiv.innerHTML = `${this.BOMB_CODE}: ${this.currentCount}`;\n    }\n}\n\n\nclass $9bd27645806bbcf5$export$9e5ddc564c6e0557 {\n    constructor(gameDiv){\n        this.gameDiv = gameDiv;\n        this.stopwatch = new (0, $d853b51430cfd2d2$export$e16de4ea1abb52c8)();\n        this.mineCounter = new (0, $660a63c9b22e7366$export$d6b7f92e63aee0e4)(0);\n    }\n    newGame(width, height, mines) {\n        const maxMines = width * height * .5 //no more than half mines\n        ;\n        if (mines > maxMines) alert(\"Too many mines\");\n        const newGame = new (0, $9dea8592a9741d26$export$3e25d3fc3a58268c)(width, height, mines, ()=>this.stopwatch.start(), ()=>this.stopwatch.stop(), (mineCount)=>this.mineCounter.set(mineCount));\n        this.gameDiv.textContent = \"\";\n        const minefieldDiv = document.createElement(\"div\");\n        minefieldDiv.classList.add(\"minefield\");\n        const statusDiv = document.createElement(\"div\");\n        statusDiv.classList.add(\"status-bar\");\n        minefieldDiv.appendChild(newGame.newGame());\n        statusDiv.appendChild(this.mineCounter.counterDiv);\n        statusDiv.appendChild(this.stopwatch.timer);\n        this.gameDiv.appendChild(minefieldDiv);\n        this.gameDiv.appendChild(statusDiv);\n    }\n}\n\n\nconst $ad2bcec7a0192558$var$gameDiv = document.getElementById(\"game-board\");\nconst $ad2bcec7a0192558$var$boardWidthInput = document.getElementById(\"txt-board-width\");\nconst $ad2bcec7a0192558$var$boardHeightInput = document.getElementById(\"txt-board-height\");\nconst $ad2bcec7a0192558$var$mineCountInput = document.getElementById(\"txt-mines\");\nconst $ad2bcec7a0192558$var$newGameBtn = document.getElementById(\"btn-new-game\");\nconst $ad2bcec7a0192558$var$gameBoard = new (0, $9bd27645806bbcf5$export$9e5ddc564c6e0557)($ad2bcec7a0192558$var$gameDiv);\n//default values\n$ad2bcec7a0192558$var$boardWidthInput.value = \"10\";\n$ad2bcec7a0192558$var$boardHeightInput.value = \"10\";\n$ad2bcec7a0192558$var$mineCountInput.value = \"20\";\n$ad2bcec7a0192558$var$newGameBtn.addEventListener(\"click\", ()=>{\n    const width = $ad2bcec7a0192558$var$boardWidthInput.valueAsNumber;\n    const height = $ad2bcec7a0192558$var$boardHeightInput.valueAsNumber;\n    const mines = $ad2bcec7a0192558$var$mineCountInput.valueAsNumber;\n    $ad2bcec7a0192558$var$gameBoard.newGame(width, height, mines);\n});\n$ad2bcec7a0192558$var$newGameBtn.click();\n\n\n//# sourceMappingURL=index.cdf78128.js.map\n","import { Gameboard } from \"./models/Gameboard\";\n\nconst gameDiv = <HTMLDivElement>document.getElementById('game-board');\nconst boardWidthInput = <HTMLInputElement>document.getElementById('txt-board-width');\nconst boardHeightInput = <HTMLInputElement>document.getElementById('txt-board-height');\nconst mineCountInput = <HTMLInputElement>document.getElementById('txt-mines');\nconst newGameBtn = <HTMLButtonElement>document.getElementById('btn-new-game');\n\nconst gameBoard = new Gameboard(gameDiv);\n\n//default values\nboardWidthInput.value = '10';\nboardHeightInput.value = '10';\nmineCountInput.value = '20';\n\nnewGameBtn.addEventListener('click', () => {\n    const width = boardWidthInput.valueAsNumber;\n    const height = boardHeightInput.valueAsNumber;\n    const mines = mineCountInput.valueAsNumber;\n\n    gameBoard.newGame(width, height, mines);\n});\n\nnewGameBtn.click();\n","import { Minefield } from './Minefield';\nimport { Stopwatch } from './Stopwatch';\nimport { MineCounter } from './MineCounter';\n\nexport class Gameboard {\n    private stopwatch: Stopwatch;\n    private mineCounter: MineCounter;\n\n    private readonly gameDiv: HTMLDivElement;\n\n    constructor(gameDiv: HTMLDivElement) {\n        this.gameDiv = gameDiv;\n        this.stopwatch = new Stopwatch();\n        this.mineCounter = new MineCounter(0);\n    }\n\n    public newGame(width: number, height: number, mines: number): void {\n        const maxMines = width*height*.5 //no more than half mines\n    \n        if (mines > maxMines) alert('Too many mines');\n    \n        const newGame = new Minefield(\n            width, \n            height, \n            mines, \n            () => this.stopwatch.start(), \n            () => this.stopwatch.stop(), \n            (mineCount: number) => this.mineCounter.set(mineCount)\n        );\n\n        this.gameDiv.textContent = '';\n        const minefieldDiv = document.createElement('div');\n        minefieldDiv.classList.add('minefield');\n        const statusDiv = document.createElement('div');\n        statusDiv.classList.add('status-bar')\n    \n        minefieldDiv.appendChild(newGame.newGame());\n        statusDiv.appendChild(this.mineCounter.counterDiv);\n        statusDiv.appendChild(this.stopwatch.timer);\n    \n        this.gameDiv.appendChild(minefieldDiv);\n        this.gameDiv.appendChild(statusDiv);\n    }\n}\n\n","import { Cell } from './Cell';\nimport { CellCoordinate } from './CellCoordinate';\nimport { NearbyCellMap } from './NearbyCellMap';\n\nexport class Minefield {\n    readonly boardWidth: number;\n    readonly boardHeight: number;\n    readonly mineCount: number;\n    private remainingMines = 0;\n\n    private readonly gameStartCallback: Function;\n    private readonly gameEndCallback: Function;\n    private readonly mineCountCallback: Function;\n\n    private virginBoard = true; //new, untouched minefield\n\n    private cells: Cell[][]; //the virtual representation of the board\n\n    constructor(\n        width: number, \n        height: number, \n        mines: number,\n        gameStartCallback: Function,\n        gameEndCallback: Function,\n        mineCountCallback: Function) {\n        this.boardHeight = height;\n        this.boardWidth = width;\n        this.mineCount = mines;\n        this.remainingMines = mines;\n\n        this.gameEndCallback = gameEndCallback;\n        this.gameStartCallback = gameStartCallback;\n        this.mineCountCallback = mineCountCallback;\n\n        this.mineCountCallback(mines);\n\n        this.cells = [...Array(width)].map(e => Array(height));\n\n        this.populateBoard();\n    }\n\n    //create a randomized minefield based on height/width/mines specified\n    //leave a gap at the point of the initial click\n    private generateMineMap(\n        initialX: number, \n        initialY: number, \n        width: number, \n        height: number, \n        mineCount: number): CellCoordinate[] {\n        const allCells: CellCoordinate[] = []; //all possible cells\n        const minedCells: CellCoordinate[] = []; //cells that have a mine\n\n        //populate full cellArray with all possible cell coordinates\n        for(let y = 0; y < height; y++) {\n            for(let x = 0; x < width; x++) {\n                allCells.push(new CellCoordinate(x, y));\n            }\n        }\n\n        //remove the initial clicked cell and all it's immediate neighbors\n        //as possible locations for a mine\n        const mineableCells: CellCoordinate[] = [];\n        for(const cell of allCells) {\n            if ((cell.x >= initialX-1 && cell.x <= initialX+1)\n                && (cell.y >= initialY-1 && cell.y <= initialY+1)) {\n                    continue;\n                }\n            mineableCells.push(cell);\n        }\n       \n        //add the specified number of mines randomly to the remaining cells\n        for (let m = 0; m < mineCount; m++) {\n            const randomCellNum = Math.floor(Math.random() * mineableCells.length);\n            minedCells.push(...mineableCells.splice(randomCellNum, 1));\n        }\n\n        return minedCells\n    }\n\n    public populateBoard(): void {\n        for(let y = 0; y < this.boardHeight; y++) {\n            for(let x = 0; x < this.boardWidth; x++) {\n                const newCell = new Cell((result:boolean) => \n                    this.cellRevealCallback(result, x, y),\n                    (flagged: boolean) => this.cellFlagCallback(flagged),\n                    (nearby: number) => this.multiFlagCallback(x, y, nearby),\n                    (nearby: number) => this.chordCallback(x, y, nearby));\n                this.cells[x][y] = newCell;\n            }\n        }\n    }\n\n    //chording is when you do a normal click on a revealed cell in order\n    //to reveal its unrevealed neighbors. If the number of nearby flagged cells\n    //equals the number on the clicked cell, each unflagged, unrevealed cell should\n    //be revealed. This can result in game loss. \n    private chordCallback(x: number, y: number, mineNeighbors: number) {\n        const cellMap = this.mapNearbyCells(x, y);\n\n        if (cellMap.Flagged.length === mineNeighbors) {\n            cellMap.Unflagged.forEach(cell => cell.reveal());\n        }\n    }\n\n    //get a map of all nearby cells and their states\n    private mapNearbyCells(x: number, y: number): NearbyCellMap {\n        const cellMap = new NearbyCellMap();\n\n        const minY = y === 0 ? 0 : y - 1;\n        const maxY = y === this.boardHeight - 1 ? y : y+1;\n        const minX = x === 0 ? 0 : x-1;\n        const maxX = x === this.boardWidth - 1 ? x : x+1;\n\n        for(let itY = minY; itY <= maxY; itY++) {\n            for (let itX = minX; itX <= maxX; itX++) {\n                if (itX === x && itY === y) continue; //no need to count myself\n                const currentCell = this.cells[itX][itY];\n\n                if (!currentCell.isRevealed()) cellMap.Unrevealed++;\n                if (!currentCell.isRevealed() && currentCell.isFlagged()) cellMap.Flagged.push(currentCell);\n                if (!currentCell.isRevealed() && !currentCell.isFlagged()) cellMap.Unflagged.push(currentCell);\n            }\n        }\n\n        return cellMap;\n    }\n\n    //when a cell gets flagged, we need to recalculate the number\n    //of remaining mines. Also, this can flag other cells if the\n    //user uses the convience feature of flagging a \"numbered\" \n    //revealed cell.\n    private cellFlagCallback(flagged: boolean): void {\n        if (flagged) this.mineCountCallback(--this.remainingMines);\n        else this.mineCountCallback(++this.remainingMines);\n        if(this.checkForWinByFlags()) this.winnerWinner();\n    }\n\n    private multiFlagCallback(x: number, y: number, nearbyMined: number): void {\n        const cellMap = this.mapNearbyCells(x, y);\n\n        if (cellMap.Unrevealed === nearbyMined) {\n            cellMap.Unflagged.forEach(n => n.toggleFlag());\n        }\n    }\n\n    //set the number that will appear on the cells near a mine\n    private calculateMinedNeighbors(): void {\n        for(let y = 0; y < this.boardHeight; y++) {\n            for(let x = 0; x < this.boardWidth; x++) {\n                if(!this.cells[x][y].isMined()) {\n                    let count = 0;\n\n                    //calculate current row\n                    if (x > 0 && this.cells[x-1][y].isMined()) count++;\n                    if (x < this.boardWidth - 1 && this.cells[x+1][y].isMined()) count++;\n    \n                    //calculate above row\n                    if (y > 0) {\n                        if (x > 0 && this.cells[x-1][y-1].isMined()) count++;\n                        if (this.cells[x][y-1].isMined()) count++;\n                        if (x < this.boardWidth - 1 && this.cells[x+1][y-1].isMined()) count++;\n                    }\n    \n                    //calculate below row\n                    if (y < this.boardHeight - 1) {\n                        if (x > 0 && this.cells[x-1][y+1].isMined()) count++;\n                        if (this.cells[x][y+1].isMined()) count++;\n                        if (x < this.boardWidth - 1 && this.cells[x+1][y+1].isMined()) count++;\n                    }\n    \n                    this.cells[x][y].setMinedNeighbors(count);\n                }\n            }\n        }\n    }\n\n    //right after the first move we need to do a bunch of stuff,\n    //like calculating the minefield, enabling flagging\n    private firstMove(x: number, y: number): void {\n        const mineMap = this.generateMineMap(\n            x,\n            y,\n            this.boardWidth, \n            this.boardHeight, \n            this.mineCount\n        );\n\n        for(let y = 0; y < this.boardHeight; y++) {\n            for(let x = 0; x < this.boardWidth; x++) {\n                if (mineMap.some(c => c.x === x && c.y === y))\n                    this.cells[x][y].arm();\n                this.cells[x][y].enableFlagging();\n            }\n        }\n\n        this.calculateMinedNeighbors();\n        this.virginBoard = false;\n        this.gameStartCallback();\n    }\n    \n    /*\n     * When a cell is revealed, this function is run to see what actions\n     * the board should take, eg declare win, loss, or propagate an empty\n     * cell field. In the latter case, this method is recursive.\n     * \n     * If the cell is not empty or mined, we don't need to do anything.\n     * \n     * result: false if the cell is mined, true if it is\n     * x, y: coordinates for the revealed cell\n     */\n    private cellRevealCallback(mined: boolean, x: number, y: number) {\n        //on the first click, we need to calculate the mines before we\n        //do anything else\n        if (this.virginBoard) this.firstMove(x, y);\n    \n        if (mined) {\n            //explode\n            this.gameEndCallback();\n            this.disableAllCells();\n        }\n        else if (this.cells[x][y].isEmpty()) {\n            //propagate empty cells\n            for (let x2 = x-1; x2 < x+2; x2++) {\n                for (let y2 = y-1; y2 < y+2; y2++) {\n                    if (x2 >= 0 \n                        && x2 < this.boardWidth \n                        && y2 >= 0 \n                        && y2 < this.boardHeight\n                        && !this.cells[x2][y2].isRevealed()) {\n                            this.cells[x2][y2].reveal();\n\n                        if (this.cells[x2][y2].isEmpty())\n                            this.cellRevealCallback(false, x2, y2);\n                    }\n                }\n            }\n        }\n        else {\n            //check for win\n            if (this.checkForWin()) this.winnerWinner();\n        }\n    }\n\n    //used when the user has won to flag remaining mines\n    private flagAllMinesRevealUnrevealed(): void {\n        for (const row of this.cells) {\n            for (const cell of row) {\n                if (cell.isMined() && !cell.isFlagged())\n                    cell.toggleFlag();\n                else if (!cell.isRevealed())\n                    cell.reveal();\n            }\n        }\n    }\n\n    private winnerWinner(): void {\n        this.gameEndCallback();\n        this.flagAllMinesRevealUnrevealed();\n        this.disableAllCells();\n    }\n\n    //check to see if the user has won\n    //TODO probably a smarter way to do this?\n    private checkForWin(): boolean {\n        for(const row of this.cells) {\n            for (const cell of row) {\n                if (!cell.isRevealed() && !cell.isMined())\n                    return false;\n            }\n        }\n\n        return true;\n    }\n\n    //check to see if a user has won by flagging all mines\n    private checkForWinByFlags = () => this.cells\n        .flatMap(r => r.filter(c => c.isMined() && !c.isFlagged()))\n        .length === 0;\n\n    //used when the user has won/lost to prevent further clicks\n    private disableAllCells(): void {\n        for(const row of this.cells) {\n            for(const cell of row) {\n                cell.gameOver();\n            }\n        }\n    }\n\n    //start a new game!\n    public newGame(): HTMLDivElement {\n        const mainDiv: HTMLDivElement = document.createElement('div');\n\n        for(let y = 0; y < this.boardHeight; y++) {\n            const newCellRow = <HTMLDivElement>document.createElement('div');\n            newCellRow.classList.add('cell-row');\n\n            for (let x = 0; x < this.boardWidth; x++) {\n                newCellRow.appendChild(this.cells[x][y].htmlElement);\n            }\n\n            mainDiv.appendChild(newCellRow);\n        }\n        return mainDiv;\n    }\n}","// An individual cell within the minefield\nexport class Cell {\n    readonly htmlElement: HTMLDivElement;\n    private readonly cellRevealCallback: Function;\n    private readonly cellFlagCallback: Function;\n    private readonly multiFlagCallback: Function;\n    private readonly chordCallback: Function;\n    private mineNeighbors = 0; \n\n    private mined = false;\n    private flagged = false;\n    private exploded = false;\n    private revealed = false;\n    private disabled = false;\n    private flaggingEnabled = false;\n    private touchTimer = 0;\n\n    private readonly BOMB_CODE = '&#x1f4a3;';\n    private readonly FLAG_CODE = '&#x26f3;';\n\n    constructor(\n        cellRevealCallback: Function, \n        cellFlagCallback: Function, \n        multiFlagCallback: Function,\n        chordCallback: Function) {\n        this.htmlElement = <HTMLDivElement>document.createElement('div');\n        this.cellRevealCallback = cellRevealCallback;\n        this.cellFlagCallback = cellFlagCallback;\n        this.multiFlagCallback = multiFlagCallback;\n        this.chordCallback = chordCallback;\n\n        this.htmlElement.classList.add('game-cell');\n        this.htmlElement.classList.add('un-revealed');\n\n        this.htmlElement.addEventListener('contextmenu', (e) => {\n            e.preventDefault();\n            this.toggleFlag();\n        });\n        this.htmlElement.addEventListener('click', () => this.reveal());\n        this.htmlElement.addEventListener('touchstart', (e) => this.touchHandler(e));\n        this.htmlElement.addEventListener('touchend', () => this.cancelTouch());\n        this.htmlElement.addEventListener('touchmove', () => this.cancelTouch());\n    }\n\n    private touchHandler(e: TouchEvent) {\n        e.preventDefault();\n        if (!this.touchTimer) {\n            this.touchTimer = setTimeout(() => {\n                this.touchTimer = 0;\n                this.toggleFlag();\n            }, 250);\n        }\n    }\n\n    private cancelTouch(): void {\n        if (this.touchTimer) {\n            clearTimeout(this.touchTimer);\n            this.touchTimer = 0;\n            this.reveal();\n        }\n    }\n\n    //set a mine on this cell\n    public arm(): void {\n        this.mined = true;\n        this.mineNeighbors = 1;\n    }\n\n    //needed to prevent a bug for flagging before the game has started\n    public enableFlagging(): void {\n        this.flaggingEnabled = true;\n    }\n\n    //set the number that will appear on a cell\n    public setMinedNeighbors(minedNeighbors: number) {\n        if (!this.mined) {\n            this.mineNeighbors = minedNeighbors;\n        }\n    }\n\n    //action when an unflagged cell is clicked\n    public reveal() {\n        if (!this.disabled && !this.flagged && !this.revealed) {\n            this.revealed = true;\n\n            if (this.mined) {\n                this.cellRevealCallback(true);\n                this.exploded = true;\n                this.htmlElement.classList.add('exploded');\n                this.htmlElement.innerHTML = this.BOMB_CODE;\n            } else {\n                this.cellRevealCallback(false);\n                if (this.mineNeighbors > 0) {\n                    this.htmlElement.textContent = this.mineNeighbors.toString();\n                    this.htmlElement.classList.add(`n${this.mineNeighbors}`);\n                }\n                \n            }\n\n            this.htmlElement.classList.remove('un-revealed');\n        } else if (this.revealed && this.mineNeighbors > 0) { //chording\n            this.chordCallback(this.mineNeighbors);\n        }\n    }\n\n    //when the game is over disable the cell from being clicked \n    public gameOver() {\n        this.disabled = true;\n\n        if (this.mined && !this.flagged && !this.exploded) {\n            this.htmlElement.classList.add('unexploded-mine');\n            this.htmlElement.innerHTML = this.BOMB_CODE;\n        }\n        else if (!this.mined && this.flagged) {\n            this.htmlElement.classList.add('bad-flag')\n        }\n    }\n\n\n    //add/remove flag from an unrevelead cell\n    public toggleFlag(): void {\n        if (this.flaggingEnabled && !this.disabled && !this.isRevealed()) {\n            if (!this.isFlagged()) {\n                this.htmlElement.innerHTML = this.FLAG_CODE;\n            } else {\n                this.htmlElement.textContent = ' ';\n            }\n\n            this.flagged = !this.flagged;\n            this.cellFlagCallback(this.flagged);\n        }\n        \n        //convenience feature - flag all nearby cells if the number on the cell\n        //matches the number of un-revealed cells nearby\n        else if (this.revealed && this.mineNeighbors > 0) {\n            this.multiFlagCallback(this.mineNeighbors);\n        }\n    }\n\n    public isFlagged = () => this.flagged;\n    public isRevealed = () => this.revealed;\n    public numNearbyMines = () => this.mineNeighbors;\n    public isEmpty = () => this.mineNeighbors === 0;\n    public isMined = () => this.mined;\n}","export class CellCoordinate {\n    readonly x: number;\n    readonly y: number;\n\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n}","import { Cell } from \"./Cell\"\n\nexport class NearbyCellMap {\n    public Unflagged: Cell[] = [];\n    public Flagged: Cell[] = [];\n    public Unrevealed: number = 0;\n}","export class Stopwatch {\n    private interval: number = 0;\n    private offset: number = 0;\n    readonly timer: HTMLDivElement;\n    \n    constructor() {\n        this.timer = document.createElement('div');\n        this.timer.classList.add('game-timer');\n        this.render(0);\n    }\n\n    public start(): void {\n        this.reset();\n        if (!this.interval) {\n            this.offset = Date.now();\n            this.interval = setInterval(() => this.update(),100);\n        }\n    }\n\n    public reset() {\n        this.stop();\n        this.render(0);\n    }\n\n    public stop(): void {\n        if (this.interval) {\n            clearInterval(this.interval);\n            this.interval = 0;\n        }\n    }\n\n    private update() {\n        this.render(Date.now() - this.offset);\n    }\n\n    private render(time: number) {\n        const minutes = Math.floor(time / 60000).toString().padStart(2, '0');\n        const seconds = ((time % 60000) / 1000).toFixed(1).padStart(4, '0');\n        this.timer.innerHTML = `${minutes}:${seconds}`;\n    }\n\n}","export class MineCounter {\n    readonly counterDiv: HTMLDivElement;\n    private currentCount: number;\n    private readonly BOMB_CODE = '&#x1f4a3;';\n\n    constructor(initialCount: number) {\n        this.counterDiv = document.createElement('div');\n        this.counterDiv.id = 'mine-counter';\n        this.currentCount = initialCount;\n        this.render();\n    }\n\n    public set(count:number): void {\n        this.currentCount = count;\n        this.render();\n    }\n\n    private render(): void {\n        this.counterDiv.innerHTML = `${this.BOMB_CODE}: ${this.currentCount}`;\n    }\n}"],"names":["$f03a6e87241b40b6$export$f6f0c3fe4ec306ea","constructor","cellRevealCallback","cellFlagCallback","multiFlagCallback","chordCallback","mineNeighbors","mined","flagged","exploded","revealed","disabled","flaggingEnabled","touchTimer","BOMB_CODE","FLAG_CODE","isFlagged","isRevealed","numNearbyMines","isEmpty","isMined","htmlElement","document","createElement","classList","add","addEventListener","e","preventDefault","toggleFlag","reveal","touchHandler","cancelTouch","setTimeout","clearTimeout","arm","enableFlagging","setMinedNeighbors","minedNeighbors","innerHTML","textContent","toString","remove","gameOver","$d74dfbfeecf2573c$export$938320e50a99d1b5","x","y","$398861d148eae71c$export$ef6ffcab40d2e0ba","Unflagged","Flagged","Unrevealed","$9dea8592a9741d26$export$3e25d3fc3a58268c","width","height","mines","gameStartCallback","gameEndCallback","mineCountCallback","remainingMines","virginBoard","checkForWinByFlags","cells","flatMap","r","filter","c","length","boardHeight","boardWidth","mineCount","Array","map","populateBoard","generateMineMap","initialX","initialY","allCells","minedCells","push","mineableCells","cell","m","randomCellNum","Math","floor","random","splice","newCell","result","nearby","cellMap","mapNearbyCells","forEach","minY","maxY","minX","maxX","itY","itX","currentCell","winnerWinner","nearbyMined","n","calculateMinedNeighbors","count","firstMove","mineMap","some","disableAllCells","x2","y2","checkForWin","flagAllMinesRevealUnrevealed","row","newGame","mainDiv","newCellRow","appendChild","$d853b51430cfd2d2$export$e16de4ea1abb52c8","interval","offset","timer","render","start","reset","Date","now","setInterval","update","stop","clearInterval","time","minutes","padStart","seconds","toFixed","$660a63c9b22e7366$export$d6b7f92e63aee0e4","initialCount","counterDiv","id","currentCount","set","$ad2bcec7a0192558$var$gameDiv","getElementById","$ad2bcec7a0192558$var$boardWidthInput","$ad2bcec7a0192558$var$boardHeightInput","$ad2bcec7a0192558$var$mineCountInput","$ad2bcec7a0192558$var$newGameBtn","$ad2bcec7a0192558$var$gameBoard","gameDiv","stopwatch","mineCounter","maxMines","alert","minefieldDiv","statusDiv","value","valueAsNumber","click"],"version":3,"file":"index.cdf78128.js.map"}